# -*- coding: utf-8 -*-
"""
CDAC energy calculation code
"""

import numpy as np

class CDAC:
    """
    A class representing a CDAC
    
    Attributes:
    bits (int): The number of bits in the CDAC.
    Vref (float): The reference voltage of the CDAC.
    C0 (float): The capacitance of the least significant bit (LSB) capacitor.
    code_num (int): The total number of codes that can be generated by the CDAC.
    caps (numpy.ndarray): An array of capacitors in the CDAC, with a size of bits excluding the constant capacitor.
    energy vectors (numpy.ndarray): The total and temporal energy consumption 
    of the CDAC. One for each charge distribution method.
    """
    def __init__(self, bits, Vref, C0):
        self.bits = bits
        self.Vref = Vref
        self.C0 = C0
        
        self.code_num = 2**bits
        
        # the size of the capacitors in the cdac (excluding the constant 1 that never switches)
        self.caps = 2**np.flip(np.arange(bits)) * C0

        # initialize the total energy arrays
        self.energy_conv  = np.zeros(self.code_num)
        self.energy_2step = np.ones(self.code_num)
        self.energy_cs    = np.ones(self.code_num)
        self.energy_split = np.ones(self.code_num)

        # initialize the temporal energy arrays
        self.conv_temporal  = np.zeros((self.code_num, bits))
        self.split_temporal = np.zeros((self.code_num, bits))
        self.cs_temporal    = np.zeros((self.code_num, bits))
        self.step_temporal  = np.zeros((self.code_num, bits))
        
        # first step of charging msb will always require 2**(bits-2) * C0 * Vref**2
        self.conv_temporal[:,0]  = np.ones(self.code_num) * 2**(bits-2) * C0 * Vref**2
        self.split_temporal[:,0] = np.ones(self.code_num) * 2**(bits-2) * C0 * Vref**2
        self.cs_temporal[:,0]    = np.ones(self.code_num) * 2**(bits-2) * C0 * Vref**2
        self.step_temporal[:,0]  = np.ones(self.code_num) * 2**(bits-2) * C0 * Vref**2
        
    def num_to_binary_array(self, num, N):
        """
        Converts a given number to a binary numpy array of N bits.
        
        Args:
        num (int): The number to be converted to binary array.
        N (int): The number of bits in the resulting binary array.
        
        Returns:
        numpy.ndarray: A numpy array of integers representing the binary 
        equivalent of the given number. The array contains N bits, with 
        leading zeros if necessary.
        """
        binary_str = bin(num)[2:].zfill(N)  # Convert the number to binary and pad with leading zeros
        binary_arr = np.array([int(digit) for digit in binary_str])  # Convert the binary string to a numpy array of integers
        return binary_arr
    
    def calculate_energies(self):
        """
        Calculate the energy consumed by the CDAC for each switching sequence 
        for each output code.
        """
        # loop for each output code
        for i in range(self.code_num):
            # get the binary sequence for the output code as a np array
            code = self.num_to_binary_array(i, self.bits)
            # loop for each switching sequence
            # first loop is unwrapped as it always leaks 2**(bits-2) * C0
            for sw in range(1, self.bits):
                # there will be a down transition if the prior bit of the output code
                # was equal to zero. up transition otherwise
                down_trans = code[sw-1] == 0
                
                # extract first sw bits of code
                C = np.concatenate((np.ones(sw), np.zeros(self.bits-sw))) * code
                # add up the capacitance of first sw bits connected to top plate
                # add on the sw-th bit because it will always be connected to vcc
                Ct = np.sum(C * self.caps) + self.caps[sw]
                
                # 2**(-1*sw - 1) * Vref will be |deltaVx|
                delVx = 2**(-1*sw - 1) * self.Vref
                # correct for the sign of Etop depending on up or down transition
                delVx = -delVx if down_trans else delVx
                
                Etop = -1 * Ct * self.Vref * delVx       # Etop equation from paper
                Esw = 2**(self.bits-sw-1) * self.C0 * self.Vref**2 # Esw equation from paper
                
                # conventional switching gets Etop + Esw always
                self.conv_temporal[i,sw] = Etop + Esw
                
                # add energy depending on up transition or down transition
                if down_trans:
                    self.split_temporal[i,sw] = Etop
                    self.cs_temporal[i,sw] = Etop + Esw / 3
                    self.step_temporal[i,sw] = Etop + Esw + 2**(self.bits - sw) * self.C0 * self.Vref * delVx
                    
                else:
                    self.split_temporal[i,sw] = Etop + Esw
                    self.cs_temporal[i,sw] = Etop + Esw
                    self.step_temporal[i,sw] = Etop + Esw
        
        # now that we have the temporal energy, calculate the total energies
        self.calculate_total_energies()
    
    def calculate_total_energies(self):
        """
        Calculates the total energy consumed for each of the four DAC 
        switching schemes: conventional, split, charge scaling, and two-step. 
        It sums up the temporal energy for each switching sequence and stores 
        it in the corresponding energy arrays.
        """
        self.energy_conv  = np.sum(self.conv_temporal,  axis=1)
        self.energy_split = np.sum(self.split_temporal, axis=1)
        self.energy_cs    = np.sum(self.cs_temporal,    axis=1)
        self.energy_2step = np.sum(self.step_temporal,  axis=1)



